#if NET6_0_OR_GREATER
using System;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient;

namespace Quine.SqlInvoke;

/// <summary>
/// Provides methods for executing for basic CRUD operations over entities.  An "entity" is identified by a key and maps to
/// a table or view.  Only columns present in the row accessor that created this will be affected by the statements.  This
/// class is thread-safe.
/// </summary>
/// <remarks>
/// <para>
/// The generated SQL statement for every operation checks <c>@@ROWCOUNT</c> and if it is greater than 1, it raises and
/// exception with error code <see cref="SqlContext.ErrorNumber_InvalidEntityKey"/>. Update and delete operations begin a transaction
/// if it is not provided to the call.  If <c>@@ROWCOUNT</c> is greater than 1, the transaction is rolled back before the
/// exception is thrown.  Otherwise, the transaction is committed.  The exception is propagated to the client code as
/// <see cref="SqlException"/> with the same error number.
/// </para>
/// <para>
/// TODO: Support for OUTPUT clause for insert/update/delete should be added.  Until then, it is cumbersome and
/// suboptimal to use autogenerated keys with insert.
/// </para>
/// </remarks>
/// <typeparam name="TRow">The underlying class representing the entity.</typeparam>
public struct SqlEntityOperationsBuilder<TRow> where  TRow : class
{
    internal readonly SqlRowAccessor<TRow> RowAccessor;

    internal SqlEntityOperationsBuilder(SqlRowAccessor<TRow> rowAccessor) {
        if (rowAccessor.TableName == null)
            throw new InvalidConfigurationException("Entity operations are not applicable to types not mapped to a table/view.", type: typeof(TRow));
        this.RowAccessor = rowAccessor;
    }

    /// <summary>
    /// An instance of this class is returned by one of the <c>Get*</c> methods.
    /// This interface is not intended to be implemented by the client code.
    /// </summary>
    public interface IEntityOperation : IDisposable
    {
        /// <summary>
        /// The underlying command to be executed.  May be further configured before execution.
        /// </summary>
        SqlCommand SqlCommand { get; }

        /// <summary>
        /// Executes the statement targeting a single entity.
        /// </summary>
        /// <param name="entity">Entity object, with at least key columns filled in.</param>
        /// <returns>
        /// True if exactly one entity was affected, false otherwise.
        /// </returns>
        /// <exception cref="SqlException">
        /// More than one entity would be affected.  If an explicit transaction is used, it should be rolled back manually.
        /// The error nummber will be <see cref="SqlContext.ErrorNumber_InvalidEntityKey"/>.
        /// </exception>
        Task<bool> ExecuteAsync(TRow entity);

        /// <summary>
        /// Synchronous version of <see cref="ExecuteAsync(TRow)"/>.
        /// </summary>
        bool Execute(TRow entity);
    }

    /// <summary>
    /// Constructs an executable select statement.
    /// </summary>
    /// <param name="sqlconn">Connection to use.</param>
    /// <param name="tx">Optional transaction.</param>
    /// <seealso cref="SqlRowAccessor{TRow}.Project(Expression{Func{TRow, object}}, bool)"/>
    public IEntityOperation GetSelect(SqlConnection sqlconn, SqlTransaction tx = null)
        => CreateEntityOperation<SelectImpl>(true, sqlconn, tx);

    /// <summary>
    /// Constructs an executable insert statement.  Computed columns are omitted.
    /// This operation does not require that the row accessor defines a key.
    /// </summary>
    /// <seealso cref="SqlRowAccessor{TRow}.Project(Expression{Func{TRow, object}}, bool)"/>
    public IEntityOperation GetInsert(SqlConnection sqlconn, SqlTransaction tx = null)
        => CreateEntityOperation<InsertImpl>(false, sqlconn, tx);

    /// <summary>
    /// Constructs an executable update statement.
    /// Computed and key columns are omitted, even if present in <paramref name="selectors"/>.
    /// </summary>
    /// <param name="sqlconn">Connection to use.</param>
    /// <param name="tx">Optional transaction.</param>
    /// <seealso cref="SqlRowAccessor{TRow}.Project(Expression{Func{TRow, object}}, bool)"/>
    public IEntityOperation GetUpdate(SqlConnection sqlconn, SqlTransaction tx = null)
        => CreateEntityOperation<UpdateImpl>(true, sqlconn, tx);

    /// <summary>
    /// Constructs an executable delete statement.
    /// </summary>
    public IEntityOperation GetDelete(SqlConnection sqlconn, SqlTransaction tx = null)
        => CreateEntityOperation<DeleteImpl>(true, sqlconn, tx);  // Project to key only

    private IEntityOperation CreateEntityOperation<TOperation>(
        bool requireKey,
        SqlConnection sqlconn,
        SqlTransaction tx
    ) where TOperation : SqlInvokable<TRow>, new()
    {
        if (requireKey) {
            if (RowAccessor.KeyColumns == null)
                throw new InvalidConfigurationException("The operation is invalid for keyless entity.", type: typeof(TRow));
            if (RowAccessor.Columns.Intersect(RowAccessor.KeyColumns).Count() != RowAccessor.KeyColumns.Count)
                throw new InvalidConfigurationException("The operation must include all key columns in the row accessor.", type: typeof(TRow));
        }
        return (IEntityOperation)RowAccessor.CreateInvokable<TOperation>().CreateExecutable(sqlconn, tx);
    }

    /////////////////////////////////////////////////////////////////////////

    static private readonly string ThrowSqlFragment = $"THROW {SqlContext.ErrorNumber_InvalidEntityKey}, 'More than one row was selected.', 1;";

    static private readonly string BeginTransactionSqlFragment =
@"DECLARE @OuterTranCount INT = @@TRANCOUNT;
IF @OuterTranCount = 0 BEGIN TRANSACTION;
ELSE SAVE TRANSACTION [SqlInvokeCrud];";

    static private readonly string EndTransactionSqlFragment =
@$"IF @@ROWCOUNT > 1 BEGIN
  IF @OuterTranCount = 0 ROLLBACK TRANSACTION;
  ELSE ROLLBACK TRANSACTION [SqlInvokeCrud];
  {ThrowSqlFragment}
END ELSE IF @OuterTranCount = 0
  COMMIT;";

    static private string GetKeyConditionFragment(SqlRowAccessor<TRow> ra) =>
        string.Join(" AND ", ra.KeyColumns.Select(x => string.Format("{0} = {1}", x.SqlName.Q, x.SqlName.P)));

    private class ExecutableWithEntityOperation : SqlExecutable<TRow>, IEntityOperation
    {
        internal ExecutableWithEntityOperation(SqlRowAccessor<TRow> rowAccessor, SqlCommand sqlCommand) 
            : base(rowAccessor, sqlCommand)
        { }

        public virtual async Task<bool> ExecuteAsync(TRow entity) => (await base.ExecuteNonQueryAsync(entity)) == 1;
        public virtual bool Execute(TRow entity) => base.ExecuteNonQuery(entity) == 1;
    }

    private sealed record SelectImpl : SqlInvokable<TRow>
    {
        public override string CommandText => GetCommandText();
        public override CommandType CommandType => CommandType.Text;

        /// <summary>
        /// Table access hints to use, without <c>WITH</c> keyword, e.g., <c>(XLOCK, ROWLOCK)</c>.
        /// May be set to null.
        /// </summary>
        public string TableHint { get; set; }

        public override SqlExecutable<TRow> CreateExecutable(SqlConnection sqlconn, SqlTransaction tx = null) =>
            new SelectExecutable(RowAccessor, CreateSqlCommand(sqlconn, tx));

        private string GetCommandText() {
            var sb = new System.Text.StringBuilder(256);
            sb.AppendFormat("SELECT {0} FROM {1} {2} WHERE {3};",
                GetColumnList(),
                RowAccessor.TableName.Q,
                string.IsNullOrEmpty(TableHint) ? "" : "WITH " + TableHint,
                GetKeyConditionFragment(RowAccessor));
            sb.AppendLine();
            sb.Append("IF @@ROWCOUNT > 1 ");
            sb.AppendLine(ThrowSqlFragment);
            return sb.ToString();

            string GetColumnList() {
                var l = RowAccessor.Columns.Where(x => !RowAccessor.KeyColumns.Contains(x));
                return string.Join(',', l.Select(x => x.SqlName.Q));
            }
        }

        private class SelectExecutable : ExecutableWithEntityOperation
        {
            internal SelectExecutable(SqlRowAccessor<TRow> rowAccessor, SqlCommand sqlCommand)
                : base(rowAccessor, sqlCommand) { }

            public override async Task<bool> ExecuteAsync(TRow entity) {
                using var reader = await base.ExecuteReaderAsync(entity);
                if (!await reader.DataReader.ReadAsync())
                    return false;
                var c = RowAccessor.ReadDataRecord(reader.DataReader, entity);
                if (c != RowAccessor.Columns.Count - RowAccessor.KeyColumns.Count)
                    throw new NotImplementedException("BUG: Invalid number of columns was returned by SELECT statement.");
                await reader.DataReader.NextResultAsync();  // Get the exception record.
                return true;
            }

            public override bool Execute(TRow entity) {
                using var reader = base.ExecuteReader(entity);
                if (!reader.DataReader.Read())
                    return false;
                var c = RowAccessor.ReadDataRecord(reader.DataReader, entity);
                if (c != RowAccessor.Columns.Count - RowAccessor.KeyColumns.Count)
                    throw new NotImplementedException("BUG: Invalid number of columns was returned by SELECT statement.");
                reader.DataReader.NextResult();  // Get the exception record.
                return true;
            }
        }
    }

    private sealed record InsertImpl : SqlInvokable<TRow>
    {
        public override string CommandText => GetCommandText();
        public override CommandType CommandType => CommandType.Text;
        public override SqlExecutable<TRow> CreateExecutable(SqlConnection sqlconn, SqlTransaction tx = null) =>
            new ExecutableWithEntityOperation(RowAccessor, CreateSqlCommand(sqlconn, tx));

        private string GetCommandText() {
            var l = RowAccessor.Columns.Where(x => !x.IsComputed);
            return string.Format("INSERT INTO {0} ({1}) VALUES ({2})",
                RowAccessor.TableName.Q,
                string.Join(',', l.Select(x => x.SqlName.Q)),
                string.Join(',', l.Select(x => x.SqlName.P)));
        }
    }

    private sealed record UpdateImpl : SqlInvokable<TRow>
    {
        public override string CommandText => GetCommandText();
        public override CommandType CommandType => CommandType.Text;
        public override SqlExecutable<TRow> CreateExecutable(SqlConnection sqlconn, SqlTransaction tx = null) =>
            new ExecutableWithEntityOperation(RowAccessor, CreateSqlCommand(sqlconn, tx));

        private string GetCommandText() {
            var sb = new System.Text.StringBuilder(256);
            sb.AppendLine(BeginTransactionSqlFragment);
            sb.AppendFormat("UPDATE {0} SET {1} WHERE {2};",
                RowAccessor.TableName.Q,
                GetColumnsToUpdate(),
                GetKeyConditionFragment(RowAccessor));
            sb.AppendLine();
            sb.AppendLine(EndTransactionSqlFragment);
            return sb.ToString();

            string GetColumnsToUpdate() {
                var l = RowAccessor.Columns.Where(x => !RowAccessor.KeyColumns.Contains(x) && !x.IsComputed);
                return string.Join(',', l.Select(x => string.Format("{0} = {1}", x.SqlName.Q, x.SqlName.P)));
            }
        }
    }

    private sealed record DeleteImpl : SqlInvokable<TRow>
    {
        public override string CommandText => GetCommandText();
        public override CommandType CommandType => CommandType.Text;
        public override SqlExecutable<TRow> CreateExecutable(SqlConnection sqlconn, SqlTransaction tx = null) =>
            new ExecutableWithEntityOperation(RowAccessor, CreateSqlCommand(sqlconn, tx));

        private string GetCommandText() {
            var sb = new System.Text.StringBuilder(256);
            sb.AppendLine(BeginTransactionSqlFragment);
            sb.AppendFormat("DELETE {0} WHERE {1};",
                RowAccessor.TableName.Q,
                GetKeyConditionFragment(RowAccessor));
            sb.AppendLine();
            sb.AppendLine(EndTransactionSqlFragment);
            return sb.ToString();
        }
    }
}
#endif